\documentclass{itmo}

\setlist[itemize]{label=---}
\setlist[enumerate]{label=\arabic*)}

\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{.}{#1}}
\usepackage{tabularx}

\begin{document}

\makereporttitle{}
	{лабораторной работе №5}
	{Хранение и алгоритмы сжатия данных}
	{Компактные структуры данных}
	{}
	{Постнов~С./P4135,Нурджанян~В./P4135,Русинов~Д./P4135}
	{Бабаянц~А.~А./преподаватель}
	{}

\maketableofcontents

\chapter{Теоретическая часть}

\section{Классические n-арные деревья}

Классическое n-арное дерево — это фундаментальная структура данных, где каждый узел может иметь произвольное количество дочерних узлов.
Реализуется посредством явных указателей: каждый узел содержит ссылку на родителя и список ссылок на детей.

Структура узла:
\begin{enumerate}
	\item Значение узла (строка).
	\item Указатель на родительский узел.
	\item Список указателей на дочерние узлы.
\end{enumerate}

Достоинства:
\begin{itemize}
	\item Простая реализация.
	\item Быстрый доступ к соседним узлам (O(1) для дочерних узлов).
	\item Интуитивная структура для представления иерархических данных.
\end{itemize}

Недостатки:
\begin{itemize}
	\item Высокие накладные расходы на память из-за указателей.
	\item O(n) сложность поиска узла по значению.
	\item Плохая локальность кэша при обходе дерева.
\end{itemize}

\section{LOUDS (Level-Order Unary Degree Sequence)}

LOUDS — это компактная структура данных для хранения деревьев, которая использует битовый массив вместо явных указателей.
Представление основано на уровневом порядке обхода (BFS) и унарной кодировке степеней узлов.

Основная идея:
\begin{enumerate}
	\item Узлы нумеруются в порядке обхода в ширину (BFS).
	\item Для каждого узла с $k$ детьми добавляется $k$ единиц и один ноль в битовый массив.
	\item Инвертированный индекс (map) хранит соответствие значению узла его индекс для быстрого поиска.
\end{enumerate}

Операции над битовым массивом:
\begin{itemize}
	\item \textbf{Rank(i, bit)} — подсчитать количество заданного бита до позиции $i$.
	\item \textbf{Select(n, bit)} — найти позицию $n$-го вхождения бита.
\end{itemize}

Достоинства LOUDS:
\begin{itemize}
	\item Компактное хранение.
	\item Хорошая локальность кэша, последовательный доступ к битам.
	\item O(1) операции поиска дочерних узлов при использовании оптимизированного индекса.
\end{itemize}

Недостатки:
\begin{itemize}
	\item Сложная реализация навигации (требуется работа с битами).
	\item O(n) для наивной реализации Select и Rank (может быть оптимизирована до O(log(log(N))) и O(1) соответственно).
\end{itemize}

\chapter{Практическая часть}

В лабораторной работе реализованы две структуры данных для представления n-арных деревьев:
\begin{enumerate}
	\item Классическое дерево с явными указателями.
	\item LOUDS дерево с компактным битовым представлением.
\end{enumerate}

Произведено сравнение производительности обеих реализаций на основе четырех операций навигации:
\begin{itemize}
	\item \textbf{FirstChild} — получить первого потомка узла.
	\item \textbf{LastChild} — получить последнего потомка узла.
	\item \textbf{ChildrenCount} — получить количество потомков узла.
	\item \textbf{Parent} — получить родителя узла.
\end{itemize}

\section{Результаты работы}

Замеры времени проводились на деревьях размером от 10 до 10000 узлов.
Для каждой операции каждой размерности выполнялось 10000 операций, после чего вычислялось среднее значение.

\subsection{Использование памяти}

\begin{table}[h]
\centering
\caption{Сравнение использования памяти}
\label{tab:memory}
\begin{tabularx}{\textwidth}{|X|X|X|}
	\hline
	\textbf{Количество узлов} & \textbf{Классическое дерево (байт)} & \textbf{LOUDS дерево (байт)} \\
	\hline
	10 & 239 & 129 \\
	\hline
	50 & 1278 & 698 \\
	\hline
	100 & 2611 & 1444 \\
	\hline
	500 & 13038 & 7171 \\
	\hline
	1000 & 26059 & 14317 \\
	\hline
	5000 & 130105 & 71363 \\
	\hline
	10000 & 260344 & 142852 \\
	\hline
\end{tabularx}
\end{table}

\clearpage
\subsection{Производительность операций}

В таблицах~\ref{tab:firstchild}-~\ref{tab:parent} представлены результаты сравнения производительности функций  \texttt{FirstChild} и \texttt{Parent} соответственно.
\begin{table}[h]
\centering
\caption{Сравнение производительности: FirstChild (наносекунды)}
\label{tab:firstchild}
\begin{tabularx}{\textwidth}{|X|X|X|}
	\hline
	\textbf{Узлов} & \textbf{Классическое дерево (нс)} & \textbf{LOUDS дерево (нс)} \\
	\hline
	10 & 34 & 53 \\
	\hline
	50 & 203 & 81 \\
	\hline
	100 & 294 & 118 \\
	\hline
	500 & 1020 & 141 \\
	\hline
	1000 & 1423 & 196 \\
	\hline
	5000 & 9750 & 783 \\
	\hline
	10000 & 28360 & 1543 \\
	\hline
\end{tabularx}
\end{table}

\begin{table}[h]
\centering
\caption{Сравнение производительности: Parent (наносекунды)}
\label{tab:parent}
\begin{tabularx}{\textwidth}{|X|X|X|}
	\hline
	\textbf{Узлов} & \textbf{Классическое дерево (нс)} & \textbf{LOUDS дерево (нс)} \\
	\hline
	10 & 38 & 48 \\
	\hline
	50 & 162 & 81 \\
	\hline
	100 & 220 & 130 \\
	\hline
	500 & 746 & 272 \\
	\hline
	1000 & 1303 & 428 \\
	\hline
	5000 & 9487 & 1948 \\
	\hline
	10000 & 27782 & 3795 \\
	\hline
\end{tabularx}
\end{table}

\clearpage
В таблицах~\ref{tab:lastchild}-~\ref{tab:childrencount} представлены результаты сравнения производительности функций  \texttt{LastChild} и \texttt{ChildrenCount} соответственно.
\begin{table}[h]
\centering
\caption{Сравнение производительности: LastChild (наносекунды)}
\label{tab:lastchild}
\begin{tabularx}{\textwidth}{|X|X|X|}
	\hline
	\textbf{Узлов} & \textbf{Классическое дерево (нс)} & \textbf{LOUDS дерево (нс)} \\
	\hline
	10 & 28 & 49 \\
	\hline
	50 & 196 & 118 \\
	\hline
	100 & 268 & 150 \\
	\hline
	500 & 922 & 361 \\
	\hline
	1000 & 1345 & 534 \\
	\hline
	5000 & 9591 & 2458 \\
	\hline
	10000 & 28152 & 4857 \\
	\hline
\end{tabularx}
\end{table}

\begin{table}[h]
\centering
\caption{Сравнение производительности: ChildrenCount (наносекунды)}
\label{tab:childrencount}
\begin{tabularx}{\textwidth}{|X|X|X|}
	\hline
	\textbf{Узлов} & \textbf{Классическое дерево (нс)} & \textbf{LOUDS дерево (нс)} \\
	\hline
	10 & 31 & 68 \\
	\hline
	50 & 170 & 171 \\
	\hline
	100 & 240 & 202 \\
	\hline
	500 & 803 & 548 \\
	\hline
	1000 & 1304 & 909 \\
	\hline
	5000 & 9332 & 4215 \\
	\hline
	10000 & 27737 & 8309 \\
	\hline
\end{tabularx}
\end{table}

\clearpage
\subsection{Графики результатов сравнения}
Графики результатов сравнения представлены на рисунке~\ref{img:comparison}:
\includeimage
	{comparison}
	{f}
	{H}
	{\textwidth}
	{Сравнение классического дерева и LOUDS дерева: память и производительность всех операций}

\chapter{Выводы}

На основе проведенного анализа можно сделать следующие выводы:
\begin{enumerate}
	\item LOUDS дерево является более экономным (на $\sim$45\%) памяти по сравнению с классическим деревом, сохраняя полную функциональность.
	\item LOUDS демонстрирует существенное преимущество по времени выполнения операций (по данным измерений на дереве из 10\,000 узлов):
	\begin{itemize}
		\item FirstChild: в среднем быстрее в $\sim$18{,}4 раза (28\,360 нс против 1\,543 нс).
		\item Parent: в среднем быстрее в $\sim$7{,}3 раза (27\,782 нс против 3\,795 нс).
		\item LastChild: в среднем быстрее в $\sim$5{,}8 раза (28\,152 нс против 4\,857 нс).
		\item ChildrenCount: в среднем быстрее в $\sim$3{,}3 раза (27\,737 нс против 8\,309 нс).
	\end{itemize}
\end{enumerate}

\end{document}
